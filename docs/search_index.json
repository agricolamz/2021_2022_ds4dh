[["index.html", "Наука о данных в R для программы Цифровых гуманитарных исследований 1 О курсе", " Наука о данных в R для программы Цифровых гуманитарных исследований Г. А. Мороз, И. С. Поздняков 1 О курсе Материалы для курса Наука о данных для магистерской программы Цифровых гуманитарные исследования НИУ ВШЭ. запись 17.01.2022 "],["viz_1.html", "2 Визуализация данных 2.1 Зачем визуализировать данные? 2.2 Основы ggplot2 2.3 Столбчатые диаграммы (barplots) 2.4 Факторы 2.5 Дотплот 2.6 Гистограммы 2.7 Функции плотности 2.8 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), 2.9 Фасетизация 2.10 Визуализация комбинаций признаков", " 2 Визуализация данных library(&quot;tidyverse&quot;) 2.1 Зачем визуализировать данные? 2.1.1 Квартет Анскомба В работе Anscombe, F. J. (1973). “Graphs in Statistical Analysis” представлен следующий датасет: quartet &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/anscombe.csv&quot;) quartet quartet %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(2) 2.1.2 Датазаурус В работе Matejka and Fitzmaurice (2017) “Same Stats, Different Graphs” были представлены следующие датасеты: datasaurus &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/datasaurus.csv&quot;) datasaurus datasaurus %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(1) 2.2 Основы ggplot2 Пакет ggplot2 – современный стандарт для создания графиков в R. Для этого пакета пишут массу расширений. В сжатом виде информация про ggplot2 содержиться здесь. 2.2.1 Диаграмма рассеяния (Scaterplot) ggplot2 ggplot(data = diamonds, aes(carat, price)) + geom_point() dplyr, ggplot2 diamonds %&gt;% ggplot(aes(carat, price))+ geom_point() 2.2.2 Слои diamonds %&gt;% ggplot(aes(carat, price))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; diamonds %&gt;% ggplot(aes(carat, price))+ geom_smooth()+ geom_point() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 2.2.3 aes() diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(color = &quot;green&quot;) diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(aes(color = cut)) diamonds %&gt;% ggplot(aes(carat, price, shape = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price, label = color))+ geom_text() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_label() Иногда аннотации налезают друг на друга: library(ggrepel) diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel()+ geom_point() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color, fill = cut))+ # fill отвечает за закрашивание geom_label_repel(alpha = 0.5)+ # alpha отвечает за прозрачность geom_point() 2.2.4 Оформление diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() + labs(x = &quot;вес (в каратах)&quot;, y = &quot;цена (в долларах)&quot;, title = &quot;Связь цены и веса бриллиантов&quot;, subtitle = &quot;Данные взяты из датасеты diamonds&quot;, caption = &quot;график сделан при помощи пакета ggplot2&quot;)+ theme(legend.position = &quot;bottom&quot;) # у функции theme() огромный функционал 2.2.5 Логарифмические шкалы Рассмотрим словарь [Ляшевской, Шарова 2011] freqdict &lt;- read_tsv(&quot;https://github.com/agricolamz/2020-2021-ds4dh/raw/master/data/freq_dict_2011.csv&quot;) ## Rows: 52138 Columns: 3 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;\\t&quot; ## chr (2): lemma, pos ## dbl (1): freq_ipm ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm))+ geom_point() freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm, label = lemma))+ geom_point()+ geom_text_repel()+ scale_y_log10() 2.2.6 annotate() Функция annotate добавляет geom к графику. diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point()+ annotate(geom = &quot;rect&quot;, xmin = 4.8, xmax = 5.2, ymin = 17500, ymax = 18500, fill = &quot;red&quot;, alpha = 0.2) + annotate(geom = &quot;text&quot;, x = 4.7, y = 16600, label = &quot;помогите...\\n я в розовом\\nквадратике&quot;) Скачайте вот этот датасет и постройте диаграмму рассеяния. 2.3 Столбчатые диаграммы (barplots) Одна и та же информация может быть представлена в агрегированном и не агрегированном варианте: misspelling &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/misspelling_dataset.csv&quot;) ## Rows: 15477 Columns: 3 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (2): correct, spelling ## dbl (1): count ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. misspelling переменные spelling аггрегирована: для каждого значения представлено значение в столбце count, которое обозначает количество каждого из написаний переменные correct неаггрегированы: в этом столбце она повторяется, для того, чтобы сделать вывод, нужно отдельно посчитать количество вариантов Для аггрегированных данных используется geom_col() misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col() Перевернем оси: misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col()+ coord_flip() Для неаггрегированных данных используется geom_bar() misspelling %&gt;% ggplot(aes(correct))+ geom_bar() Перевернем оси: misspelling %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Неаггрегированный вариант можно перевести в аггрегированный: diamonds %&gt;% count(cut) Аггрегированный вариант можно перевести в неаггрегированный: diamonds %&gt;% count(cut) %&gt;% uncount(n) 2.4 Факторы Как можно заметить по предыдущему разделу, переменные на графике упорядочены по алфавиту. Чтобы это исправить нужно обсудить факторы: my_factor &lt;- factor(misspelling$correct) head(my_factor) ## [1] deschanel deschanel deschanel deschanel deschanel deschanel ## 15 Levels: deschanel galifianakis johansson kaepernick labeouf ... shyamalan levels(my_factor) ## [1] &quot;deschanel&quot; &quot;galifianakis&quot; &quot;johansson&quot; &quot;kaepernick&quot; &quot;labeouf&quot; ## [6] &quot;macaulay&quot; &quot;mcconaughey&quot; &quot;mcgwire&quot; &quot;mclachlan&quot; &quot;minaj&quot; ## [11] &quot;morissette&quot; &quot;palahniuk&quot; &quot;picabo&quot; &quot;poehler&quot; &quot;shyamalan&quot; levels(my_factor) &lt;- rev(levels(my_factor)) head(my_factor) ## [1] shyamalan shyamalan shyamalan shyamalan shyamalan shyamalan ## 15 Levels: shyamalan poehler picabo palahniuk morissette minaj ... deschanel misspelling %&gt;% mutate(correct = factor(correct, levels = c(&quot;deschanel&quot;, &quot;galifianakis&quot;, &quot;johansson&quot;, &quot;kaepernick&quot;, &quot;labeouf&quot;, &quot;macaulay&quot;, &quot;mcgwire&quot;, &quot;mclachlan&quot;, &quot;minaj&quot;, &quot;morissette&quot;, &quot;palahniuk&quot;, &quot;picabo&quot;, &quot;poehler&quot;, &quot;shyamalan&quot;, &quot;mcconaughey&quot;))) %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Для работы с факторами удобно использовать пакет forcats (входит в tidyverse, вот ссылка на cheatsheet). Иногда полезной бывает функция fct_reorder(): misspelling %&gt;% count(correct) misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n))+ geom_col()+ coord_flip() Кроме того, в функцию fct_reorder() можно добавит функцию, которая будет считаться на векторе, по которому группируют: diamonds %&gt;% mutate(cut = fct_reorder(cut, price, mean)) %&gt;% ggplot(aes(cut)) + geom_bar() В этом примере переменная cut упорядочена по средней mean цене price. Естественно, вместо mean можно использовать другие функции (median, min, max или даже собственные функции). Можно совмещать разные geom_...: misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n, label = n))+ geom_col()+ geom_text(nudge_y = 150)+ coord_flip() На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 30 самых частотоных названий пабов в Великобритании. 📋 список подсказок ➡ На новостном портале meduza.io недавно вышла новость о применения закона “о неуважении к власти в интернете”. Постройте графики из этой новости. При построении графиков я использовал цвет “tan3”. 📋 список подсказок ➡ 2.5 Дотплот Иногда для случаев, когда мы исследуем числовую переменную подходит простой график, который отображает распределение наших наблюдений на одной соответствующей числовой шкале. mtcars %&gt;% ggplot(aes(mpg)) + geom_dotplot(method = &quot;histodot&quot;) ## Bin width defaults to 1/30 of the range of the data. Pick better value with `binwidth`. По оси x отложена наша переменная, каждая точка – одно наблюдение, а отложенное по оси y стоит игнорировать – оно появляется из-за ограничений пакета ggplot2. Возможно чуть понятнее будет, если добавить geom_rug(), который непосредственно отображает каждое наблюдение. mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;) ## Bin width defaults to 1/30 of the range of the data. Pick better value with `binwidth`. Больший смысл имеет раскрашенный вариант: mtcars %&gt;% mutate(cyl = factor(cyl)) %&gt;% ggplot(aes(mpg, fill = cyl)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## Bin width defaults to 1/30 of the range of the data. Pick better value with `binwidth`. Как видно, на графике, одна синяя точка попала под одну зеленую: значит они имеют общее наблюдение. 2.6 Гистограммы Если наблюдений слишком много, дотплот не имеем много смысла: diamonds %&gt;% ggplot(aes(price)) + geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## Bin width defaults to 1/30 of the range of the data. Pick better value with `binwidth`. diamonds %&gt;% ggplot(aes(price)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Обсудим на предыдущем примере mtcars %&gt;% ggplot(aes(mpg))+ geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, а высота столбца говорит, сколько наблюдений имеют такое же наблюдение. Однако многое зависит от того, что мы считаем одинаковым значением: mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 100) mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 5) Существует три алгоритма встроенные в R, которые можно использовать и снимать с себя ответственность: [Sturgers 1926] nclass.Sturges(mtcars$mpg) [Scott 1979] nclass.scott(mtcars$mpg) [Freedman, Diaconis 1981] nclass.FD(mtcars$mpg) mtcars %&gt;% ggplot(aes(mpg)) + geom_histogram(bins = nclass.FD(mtcars$mpg)) Какой из методов использовался при создании следующего графика на основе встроенного датасета iris? В этом типе графика точно так же можно раскрашивать на основании другой переменной: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 2.7 Функции плотности Кроме того, существует способ использовать не такой рубленный график, а его сглаженную вариант, ыйторый строиться при помои функции плотядерной оценки ности. Важное свойство, которое стоит понимать про функцию плотности — что кривая, получаемая ядерной оценкой плотности, не зависит от величины коробки гистделения (хотя есть аргумент, который от adjustвечает за степень “близости” функции плотности к гистограмме). iris %&gt;% ggplot(aes(Petal.Length)) + geom_rug()+ geom_density() Таким образом мы можем сравнивать распределения: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density() Часто имеет смысл настроить прозрачность: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 Кроме того, иногда удобно разделять группы на разные уровни: # install.packages(ggridges) library(ggridges) iris %&gt;% ggplot(aes(Petal.Length, Species, fill = Species)) + geom_density_ridges(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 ## Picking joint bandwidth of 0.155 В длинный список “2015 Kantar Information is Beautiful Awards” попала визуализация Perceptions of Probability, сделанная пользователем zonination в ggplot2. Попробуйте воспроизвести ее с этими данными. 📋 список подсказок ➡ 2.8 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), Вот другие способы показать распределение числовой переменной: iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_point() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter(width = 0.3) library(&quot;ggbeeswarm&quot;) iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_quasirandom() diamonds %&gt;% ggplot(aes(cut, price))+ geom_violin() diamonds %&gt;% ggplot(aes(cut, price))+ geom_boxplot() 2.9 Фасетизация Достаточно мощным инструментом анализа данных является фасетизация, которая позволяет разбивать графики на основе какой-то переменной. diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut) При этом иногда так бывает, что наличие какой-то одного значение в одном из фасетов, заставляет иметь одну и ту же шкалу для всех остальных. Это можно изменить при помощи аргумента scales: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut, scales = &quot;free&quot;) Кроме того, можно добавлять дополнительные аргументы: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut+color) Кроме того, можно создавать сетки переменных используя geom_grid(), они facet_grid()ньше места, чем facet_wrap(): diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;) Кроме того facet_grid() позволяет делать обощающие поля, где представлены все данные по какой-то строчке или столбцу: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;, margins = TRUE) 2.10 Визуализация комбинаций признаков 2.10.1 Потоковая Диаграмма (Sankey diagram) Один из способов визуализации отношений между признаками называется потоковая диаграмма. library(&quot;ggforce&quot;) zhadina &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/zhadina.csv&quot;) ## Rows: 26 Columns: 5 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (4): word_1, word_2, word_3, type ## dbl (1): n ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. zhadina %&gt;% gather_set_data(1:3) %&gt;% ggplot(aes(x, id = id, split = y, value = n))+ geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) + geom_parallel_sets_axes(axis.width = 0.5, color = &quot;lightgrey&quot;, fill = &quot;white&quot;) + geom_parallel_sets_labels(angle = 0) + theme_no_axes()+ theme(legend.position = &quot;bottom&quot;) А как поменять порядок? Снова факторы. zhadina %&gt;% gather_set_data(1:3) %&gt;% mutate(y = fct_reorder(y, n, mean)) %&gt;% ggplot(aes(x, id = id, split = y, value = n))+ geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) + geom_parallel_sets_axes(axis.width = 0.5, color = &quot;lightgrey&quot;, fill = &quot;white&quot;) + geom_parallel_sets_labels(angle = 0) + theme_no_axes()+ theme(legend.position = &quot;bottom&quot;) Можно донастроить, задав собственный порядок в аргументе levels функции factor(). 2.10.2 UpSet Plot Если диаграмма Sankey визуализирует попарные отношения между переменными, то график UpSet потенциально может визуализировать все возможные комбинации и является хорошей альтернативой диаграмме Вена, с большим количеством переменных (см. эту статью Лауры Эллис). library(UpSetR) movies &lt;- read.csv( system.file(&quot;extdata&quot;, &quot;movies.csv&quot;, package = &quot;UpSetR&quot;), header=TRUE, sep=&quot;;&quot; ) str(movies) ## &#39;data.frame&#39;: 3883 obs. of 21 variables: ## $ Name : chr &quot;Toy Story (1995)&quot; &quot;Jumanji (1995)&quot; &quot;Grumpier Old Men (1995)&quot; &quot;Waiting to Exhale (1995)&quot; ... ## $ ReleaseDate: int 1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ... ## $ Action : int 0 0 0 0 0 1 0 0 1 1 ... ## $ Adventure : int 0 1 0 0 0 0 0 1 0 1 ... ## $ Children : int 1 1 0 0 0 0 0 1 0 0 ... ## $ Comedy : int 1 0 1 1 1 0 1 0 0 0 ... ## $ Crime : int 0 0 0 0 0 1 0 0 0 0 ... ## $ Documentary: int 0 0 0 0 0 0 0 0 0 0 ... ## $ Drama : int 0 0 0 1 0 0 0 0 0 0 ... ## $ Fantasy : int 0 1 0 0 0 0 0 0 0 0 ... ## $ Noir : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Horror : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Musical : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mystery : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Romance : int 0 0 1 0 0 0 1 0 0 0 ... ## $ SciFi : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Thriller : int 0 0 0 0 0 1 0 0 0 1 ... ## $ War : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Western : int 0 0 0 0 0 0 0 0 0 0 ... ## $ AvgRating : num 4.15 3.2 3.02 2.73 3.01 3.88 3.41 3.01 2.66 3.54 ... ## $ Watches : int 2077 701 478 170 296 940 458 68 102 888 ... upset(movies[,3:19], nsets = 16, order.by = &quot;freq&quot;) "],["strings.html", "3 Работа со строками 3.1 Работа со строками в R 3.2 Как получить строку? 3.3 Соединение и разделение строк 3.4 Количество символов 3.5 Сортировка 3.6 Поиск подстроки 3.7 Изменение строк 3.8 Регулярные выражения 3.9 Определение языка 3.10 Расстояния между строками 3.11 Дополнительные задания:", " 3 Работа со строками 3.1 Работа со строками в R Для работы со строками можно использовать: базовый R пакет stringr (часть tidyverse) пакет stringi – отдельный пакет, так что не забудьте его установить: install.packages(&quot;stringi&quot;) library(tidyverse) library(stringi) Мы будем пользоваться в основном пакетами stingr и stringi, так как они в большинстве случаях удобнее. К счастью функции этих пакетов легко отличить от остальных: функции пакет stringr всегда начинаются с str_, а функции пакета stringi — c stri_. Существует cheat sheet по stringr. 3.2 Как получить строку? следите за кавычками &quot;the quick brown fox jumps over the lazy dog&quot; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &#39;the quick brown fox jumps over the lazy dog&#39; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; ## [1] &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; &#39;the quick &quot;brown&quot; fox jumps over the lazy dog&#39; ## [1] &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; пустая строка &quot;&quot; ## [1] &quot;&quot; &#39;&#39; ## [1] &quot;&quot; character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; преобразование typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; встроенные векторы letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; Создание рандомных строк set.seed(42) stri_rand_strings(n = 10, length = 5:14) ## [1] &quot;uwHpd&quot; &quot;Wj8ehS&quot; &quot;ivFSwy7&quot; &quot;TYu8zw5V&quot; ## [5] &quot;OuRpjoOg0&quot; &quot;p0CubNR2yQ&quot; &quot;xtdycKLOm2k&quot; &quot;fAGVfylZqBGp&quot; ## [9] &quot;gE28DTCi0NV0a&quot; &quot;9MemYE55If0Cvv&quot; Перемешивает символы внутри строки stri_rand_shuffle(&quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot;) ## [1] &quot;,цо м,пюзгу сл аиъ—в кжряд,ыщьчебэн х—штё фй&quot; stri_rand_shuffle(month.name) ## [1] &quot;aJayunr&quot; &quot;eyrbraFu&quot; &quot;achMr&quot; &quot;Aplri&quot; &quot;ayM&quot; &quot;Jnue&quot; ## [7] &quot;uJly&quot; &quot;usuAgt&quot; &quot;tpebermSe&quot; &quot;tOecrbo&quot; &quot;oeNembvr&quot; &quot;Dmceerbe&quot; Генерирует псевдорандомный текст1 stri_rand_lipsum(nparagraphs = 2) ## [1] &quot;Lorem ipsum dolor sit amet, donec sit nunc urna sed ultricies ac pharetra orci luctus iaculis, ac tincidunt cum. Neque eu semper at sociosqu hendrerit. Eu aliquet lacus, eu hendrerit donec aliquam eros. Risus nibh, quam in sit facilisi ipsum. Amet sem sed donec sed molestie scelerisque tincidunt. Nisl donec et facilisis interdum non sed dolor purus. In ipsum dignissim torquent velit nec aliquam pellentesque. Ac, adipiscing, neque et at torquent, vestibulum ullamcorper. Ad dictumst enim velit non nulla felis habitant. Egestas placerat consectetur, dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra. Vestibulum leo et. Suscipit egestas in in montes, sapien gravida? Conubia purus varius ut nec feugiat.&quot; ## [2] &quot;Risus eleifend magnis neque diam, suspendisse ullamcorper nulla adipiscing malesuada massa, nisi sociosqu velit id et. Aliquam facilisis et aenean. Parturient vel ac in convallis, massa diam nibh. Nulla interdum cursus et. Natoque amet, ut praesent. Tortor ultrices a consectetur, augue natoque class faucibus? Ut sed arcu elementum magna. Dignissim ac facilisi quis ut nisl eu, massa.&quot; 3.3 Соединение и разделение строк Соединенить строки можно используя функцию str_c(), в которую, как и в функции с(), можно перечислять элементы через запятую: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller)) Кроме того, если хочется, можно использовать особенный разделитель, указав его в аргументе sep: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) Аналогичным образом, для разделение строки на подстроки можно использовать функцию separate(). Это функция разносит разделенные элементы строки в соответствующие столбцы. У функции три обязательных аргумента: col — колонка, которую следует разделить, into — вектор названий новых столбец, sep — разделитель. tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) %&gt;% separate(col = merge, into = c(&quot;column_1&quot;, &quot;column_2&quot;), sep = &quot;_&quot;) Кроме того, есть инструмент str_split(), которая позволяет разбивать строки на подстроки, но возвращает список. str_split(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;Janua&quot; &quot;y&quot; ## ## [[2]] ## [1] &quot;Feb&quot; &quot;ua&quot; &quot;y&quot; ## ## [[3]] ## [1] &quot;Ma&quot; &quot;ch&quot; ## ## [[4]] ## [1] &quot;Ap&quot; &quot;il&quot; ## ## [[5]] ## [1] &quot;May&quot; ## ## [[6]] ## [1] &quot;June&quot; ## ## [[7]] ## [1] &quot;July&quot; ## ## [[8]] ## [1] &quot;August&quot; ## ## [[9]] ## [1] &quot;Septembe&quot; &quot;&quot; ## ## [[10]] ## [1] &quot;Octobe&quot; &quot;&quot; ## ## [[11]] ## [1] &quot;Novembe&quot; &quot;&quot; ## ## [[12]] ## [1] &quot;Decembe&quot; &quot;&quot; 3.4 Количество символов 3.4.1 Подсчет количества символов tibble(mn = month.name) %&gt;% mutate(n_charactars = str_count(mn)) 3.4.2 Подгонка количества символов Можно обрезать строки, используя функцию str_trunc(): tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6)) Можно решить с какой стороны обрезать, используя аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;left&quot;)) tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;center&quot;)) Можно заменить многоточие, используя аргумент ellipsis: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 3, ellipsis = &quot;&quot;)) Можно наоборот “раздуть” строку: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10)) Опять же есть аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, side = &quot;right&quot;)) Также можно выбрать, чем “раздувать строку”: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, pad = &quot;.&quot;)) На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 40 самых частотоных названий пабов в Великобритании, отложив по оси x количество символов, а по оси y – количество баров с таким названием. 📋 список подсказок ➡ 👁 Датасет скачался, что дальше? ➡ Перво-наперво следует создать переменную, в которой бы хранилось количество каждого из баров. 👁 А как посчитать количество баров? ➡ Это можно сделать при помощи функции count(). 👁 Бары пересчитали, что дальше? ➡ Теперь нужно создать новую переменную, где бы хранилась информация о количестве символов. 👁 Все переменные есть, теперь рисуем? ➡ Не совсем. Перед тем как рисовать нужно отфильтровать 50 самых популярных. 👁 Так, все готово, а какие geom_()? ➡ На графике geom_point() и geom_text_repel() из пакета ggrepel. 👁 А-а-а-а! could not find function \"geom_text_repel\" ➡ А вы включили библиотеку ggrepel? Если не включили, то функция, естественно будет недоступна. 👁 А-а-а-а! geom_text_repel requires the following missing aesthetics: label\" ➡ Все, как написала программа: чтобы писать какой-то текст в функции aes() нужно добавить аргумент label = pub_name. Иначе откуда он узнает, что ему писать? 👁 Фуф! Все готово! ➡ А оси подписаны? А заголовок? А подпись про источник данных? 3.5 Сортировка Для сортировки существует базовая функция sort() и функция из stringr str_sort(): unsorted_latin &lt;- c(&quot;I&quot;, &quot;♥&quot;, &quot;N&quot;, &quot;Y&quot;) sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin, locale = &quot;lt&quot;) ## [1] &quot;♥&quot; &quot;I&quot; &quot;Y&quot; &quot;N&quot; unsorted_cyrillic &lt;- c(&quot;я&quot;, &quot;i&quot;, &quot;ж&quot;) str_sort(unsorted_cyrillic) ## [1] &quot;i&quot; &quot;ж&quot; &quot;я&quot; str_sort(unsorted_cyrillic, locale = &quot;ru_UA&quot;) ## [1] &quot;ж&quot; &quot;я&quot; &quot;i&quot; Список локалей на копмьютере можно посмотреть командой stringi::stri_locale_list(). Список всех локалей вообще приведен на этой странице. Еще полезные команды: stringi::stri_locale_info и stringi::stri_locale_set. Не углубляясь в разнообразие алгоритмов сортировки, отмечу, что алгоритм по-умолчанию хуже работает с большими данными: set.seed(42) huge &lt;- sample(letters, 1e7, replace = TRUE) head(huge) ## [1] &quot;q&quot; &quot;e&quot; &quot;a&quot; &quot;y&quot; &quot;j&quot; &quot;d&quot; system.time( sort(huge) ) ## user system elapsed ## 6.982 0.032 7.056 system.time( sort(huge, method = &quot;radix&quot;) ) ## user system elapsed ## 0.319 0.040 0.359 system.time( str_sort(huge) ) ## user system elapsed ## 6.628 0.052 6.681 huge_tbl &lt;- tibble(huge) system.time( huge_tbl %&gt;% arrange(huge) ) ## user system elapsed ## 34.507 0.052 34.560 Предварительный вывод: для больших данных – sort(..., method = \"radix\"). 3.6 Поиск подстроки Можно использовать функцию str_detect(): tibble(mn = month.name) %&gt;% mutate(has_r = str_detect(mn, &quot;r&quot;)) Кроме того, существует функция, которая возвращает индексы, а не значения TRUE/FALSE: tibble(mn = month.name) %&gt;% slice(str_which(mn, &quot;r&quot;)) Также можно посчитать количество вхождений какой-то подстроки: tibble(mn = month.name) %&gt;% mutate(has_r = str_count(mn, &quot;r&quot;)) 3.7 Изменение строк 3.7.1 Изменение регистра latin &lt;- &quot;tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg&quot; cyrillic &lt;- &quot;лЮбЯ, сЪеШь ЩиПцЫ, — вЗдОхНёТ мЭр, — кАйФ жГуЧ&quot; str_to_upper(latin) ## [1] &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot; str_to_lower(cyrillic) ## [1] &quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot; str_to_title(latin) ## [1] &quot;The Quick Brown Fox Jumps Over The Lazy Dog&quot; 3.7.2 Выделение подстроки Подстроку в строке можно выделить двумя способами: по индексам функцией str_sub(), и по подстроке функцией str_png(). extract(images/5.07_str_sub.png) tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 2)) tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;r&quot;)) По умолчанию функция str_extract() возвращает первое вхождение подстроки, соответствующей шаблону. Также существует функция str_extract_all(), которая возвращает все вхождения подстрок, соответствующих шаблону, однако возвращает объект типа список. str_extract_all(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;r&quot; ## ## [[2]] ## [1] &quot;r&quot; &quot;r&quot; ## ## [[3]] ## [1] &quot;r&quot; ## ## [[4]] ## [1] &quot;r&quot; ## ## [[5]] ## character(0) ## ## [[6]] ## character(0) ## ## [[7]] ## character(0) ## ## [[8]] ## character(0) ## ## [[9]] ## [1] &quot;r&quot; ## ## [[10]] ## [1] &quot;r&quot; ## ## [[11]] ## [1] &quot;r&quot; ## ## [[12]] ## [1] &quot;r&quot; 3.7.3 Замена подстроки Существует функция str_replace(), которая позволяет заменить одну подстроку в строке на другую: tibble(mn = month.name) %&gt;% mutate(mutate = str_replace(mn, &quot;r&quot;, &quot;R&quot;)) Как и другие функции str_replace() делает лишь одну замену, чтобы заменить все вхождения подстроки следует использовать функцию str_replace_all(): tibble(mn = month.name) %&gt;% mutate(mutate = str_replace_all(mn, &quot;r&quot;, &quot;R&quot;)) 3.7.4 Удаление подстроки Для удаления подстроки на основе шаблона, используется функция str_remove() и str_remove_all() tibble(month.name) %&gt;% mutate(mutate = str_remove(month.name, &quot;r&quot;)) tibble(month.name) %&gt;% mutate(mutate = str_remove_all(month.name, &quot;r&quot;)) 3.7.5 Транслитерация строк В пакете stringi сууществует достаточно много методов транслитераций строк, которые можно вывести командой stri_trans_list(). Вот пример использования некоторых из них: stri_trans_general(&quot;stringi&quot;, &quot;latin-cyrillic&quot;) ## [1] &quot;стринги&quot; stri_trans_general(&quot;сырники&quot;, &quot;cyrillic-latin&quot;) ## [1] &quot;syrniki&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-greek&quot;) ## [1] &quot;στριγγι&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-armenian&quot;) ## [1] &quot;ստրինգի&quot; Вот два датасета: список городов России частотный словарь русского языка [Шаров, Ляшевская 2011] Определите сколько городов называется обычным словом русского языка (например, город Орёл)? Не забудьте поменять ё на е. 📋 список подсказок ➡ 👁 Датасеты скачались, что дальше? ➡ Надо их преобразовать к нужному виду и объединить. 👁 А как их соединить? Что у них общего? ➡ В одном датасете есть переменная city, в другом – переменная lemma. Все города начинаются с большой буквы, все леммы с маленькой буквы. Я бы уменьшил букву в датасете с городами, сделал бы новый столбец в датасете с городами (например, town), соединил бы датасеты и посчитал бы сколько в результирующем датасете значений town. 👁 А как соеднить? ➡ Я бы использовал dict %&gt;% ... %&gt;% inner_join(cities). Если в датасетах разные названия столбцов, то следует указывать какие столбцы, каким соответствуют:dict %&gt;% ... %&gt;% inner_join(cities, by = c(\"lemma\" = \"city\")) 👁 Соединилось вроде… А как посчитать? ➡ Я бы, как обычно, использовал функцию count(). 3.8 Регулярные выражения Большинство функций из раздела об операциях над векторами (str_detect(), str_extract(), str_remove() и т. п.) имеют следующую структуру: строка, с которой работает функция образец (pattern) Дальше мы будем использовать функцию str_view_all(), которая позволяет показывать, выделенное образцом в исходной строке. str_view_all(&quot;Я всегда путаю с и c&quot;, &quot;c&quot;) # я ищу латинскую c 3.8.1 Экранирование метасимволов a &lt;- &quot;Всем известно, что 4$\\\\2 + 3$ * 5 = 17$? Да? Ну хорошо (а то я не был уверен). [|}^{|]&quot; str_view_all(a, &quot;$&quot;) str_view_all(a, &quot;\\\\$&quot;) str_view_all(a, &quot;\\\\.&quot;) str_view_all(a, &quot;\\\\*&quot;) str_view_all(a, &quot;\\\\+&quot;) str_view_all(a, &quot;\\\\?&quot;) str_view_all(a, &quot;\\\\(&quot;) str_view_all(a, &quot;\\\\)&quot;) str_view_all(a, &quot;\\\\|&quot;) str_view_all(a, &quot;\\\\^&quot;) str_view_all(a, &quot;\\\\[&quot;) str_view_all(a, &quot;\\\\]&quot;) str_view_all(a, &quot;\\\\{&quot;) str_view_all(a, &quot;\\\\}&quot;) str_view_all(a, &quot;\\\\\\\\&quot;) 3.8.2 Классы знаков \\\\d – цифры. \\\\D – не цифры. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\d&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\D&quot;) \\\\s – пробелы. \\\\S – не пробелы. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\s&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\S&quot;) \\\\w – не пробелы и не знаки препинания. \\\\W – пробелы и знаки препинания. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\w&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\W&quot;) произвольная группа символов и обратная к ней str_view_all(&quot;Умей мечтать, не став рабом мечтанья&quot;, &quot;[оауиыэёеяю]&quot;) str_view_all(&quot;И мыслить, мысли не обожествив&quot;, &quot;[^оауиыэёеяю]&quot;) встроенные группы символов str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[0-9]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[а-я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-Я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-я]&quot;) str_view_all(&quot;The quick brown Fox jumps over the lazy Dog&quot;, &quot;[a-z]&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[^0-9]&quot;) выбор из нескольких групп str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;лар|рал|арл&quot;) произвольный символ str_view_all(&quot;Везет Сенька Саньку с Сонькой на санках. Санки скок, Сеньку с ног, Соньку в лоб, все — в сугроб&quot;, &quot;[Сс].н&quot;) знак начала и конца строки str_view_all(&quot;от топота копыт пыль по полю летит.&quot;, &quot;^о&quot;) str_view_all(&quot;У ежа — ежата, у ужа — ужата&quot;, &quot;жата$&quot;) есть еще другие группы и другие обозначения уже приведенных групп, см. ?regex 3.8.3 Квантификация ? – ноль или один раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;еее?&quot;) * – ноль и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;ее*&quot;) + – один и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е+&quot;) {n} – n раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2}&quot;) {n,} – n раз и более str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{1,}&quot;) {n,m} – от n до m. Отсутствие пробела важно: {1,2} – правильно, {1,␣2} – неправильно. str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2,3}&quot;) группировка символов str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;(ов)+&quot;) str_view_all(&quot;беловатый, розоватый, розововатый&quot;, &quot;(ов)+&quot;) жадный vs. нежадный алоритмы str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*ед&quot;) str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*?ед&quot;) 3.8.4 Позиционная проверка (look arounds) Позиционная проверка – выглядит достаточно непоследовательно даже в свете остальных регулярных выражений. Давайте найдем все а перед р: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=р)&quot;) А теперь все а перед р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=[рл])&quot;) Давайте найдем все а после р str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=р)а&quot;) А теперь все а после р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=[рл])а&quot;) Также у этих выражений есть формы с отрицанием. Давайте найдем все р не перед а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;р(?!а)&quot;) А теперь все р не после а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;!а)р&quot;) Запомнить с ходу это достаточно сложно, так что подсматривайте сюда: Вот отсюда можно скачать файл с текстом стихотворения Н. Заболоцкого “Меркнут знаки задиака.” Посчитайте долю женских (ударение падает на предпоследний слог рифмующихся слов) и мужских (ударение падает на последний слог рифмующихся слов) рифм в стихотворении. 📋 список подсказок ➡ 👁 Датасеты скачивается с ошибкой, почему? ➡ Дело в том, что исходный файл в формате .txt, а не .csv. Его нужно скачивать, например, командой read_lines() 👁 Ошибка: ...applied to an object of class \"character\" ➡ Скачав файл Вы получили вектор со строками, где каждая элимент вектора – строка стихотворения. Создайте tibble(), тогда можно будет применять стандартные инструменты tidyverse. 👁 Хорошо, tibble() создан, что дальше? ➡ Дальше нужно создать переменную, из которой будет понятно, мужская в каждой строке рифма, или женская. 👁 А как определить, какая рифма? Нужно с словарем сравнивать? ➡ Формально говоря, определять рифму можно по косвенным признакам. Все стихотворение написано четырехстопным хореем, значит в нем либо 7, либо 8 слогов. Значит, посчитав количество слогов, мы поймем, какая перед нами рифма. 👁 А как посчитать гласные? ➡ Нужно написать регулярное выражение… вроде бы это тема нашего занятия… 👁 Гласные посчитаны. А что дальше? ➡ Ну теперь нужно посчитать, сколько каких длин (в количестве слогов) бывает в стихотворении. Это можно сделать при помощи функции count(). 👁 А почему у меня есть строки длины 0 слогов ➡ Ну, видимо, в стихотворении были пустые строки. Они использовались для разделения строф. 👁 А почему у меня есть строки длины 6 слогов ➡ Ну, видимо, Вы написали регулярное выражение, которое не учитывает, что гласные буквы могут быть еще и в начале строки, а значит написаны с большой буквы. В ходе анализа данных чаще всего бороться со строками и регулярными выражениями приходится в процессе обработки неаккуратнособранных анкет. Предлагаю обработать переменные sex и age такой вот неудачно собранной анкеты и построить следующий график: 📋 список подсказок ➡ 👁 А что это за geom_...()? ➡ Это geom_dotplot() с аргументом method = \"histodot\" и с удаленной осью y при помощи команды scale_y_continuous(NULL, breaks = NULL) 👁 Почему на графике рисутеся каждое значение возраста? ➡ Если Вы все правильно преобразовали, должно помочь преобразование строковой переменной age в числовую при помощи функции as.integer(). 3.9 Определение языка Для определения языка существует два пакета cld2 (вероятностный) и cld3 (нейросеть). udhr_24 &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/article_24_from_UDHR.csv&quot;) ## Rows: 6 Columns: 1 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (1): article_text ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. udhr_24 cld2::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(udhr_24$article_text, lang_code = FALSE) ## [1] &quot;RUSSIAN&quot; &quot;ENGLISH&quot; &quot;FRENCH&quot; &quot;SPANISH&quot; &quot;ARABIC&quot; &quot;CHINESE&quot; cld3::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] &quot;bg&quot; cld3::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] NA cld2::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld3::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld2::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld3::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld2::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) ## $classification ## language code latin proportion ## 1 RUSSIAN ru FALSE 0.87 ## 2 ENGLISH en TRUE 0.11 ## 3 UNKNOWN un TRUE 0.00 ## ## $bytes ## [1] 353 ## ## $reliabale ## [1] TRUE cld3::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) 3.10 Расстояния между строками Существует много разных метрик для измерения расстояния между строками (см. ?`stringdist-metrics`), в примерах используется расстояние Дамерау — Левенштейна. Данное расстояние получается при подсчете количества операций, которые нужно сделать, чтобы перевести одну строку в другую. вставка ab → aNb удаление aOb → ab замена символа aOb → aNb перестановка символов ab → ba library(stringdist) stringdist(&quot;корова&quot;,&quot;корова&quot;) ## [1] 0 stringdist(&quot;коровы&quot;, c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;)) ## [1] 4 6 6 1 5 amatch(c(&quot;быки&quot;, &quot;коровы&quot;), c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;), maxDist = 2) ## [1] 2 4 3.11 Дополнительные задания: В датасет записаны твиты Донольда Трампа взятые с kaggle. Постройте график рассеяния, которые показывает связь количества ретвитов и лайков. Чтобы убрать научную запись больших чисел используйте команду options(scipen = 999). Постройте гистограмму, которая показывает распределения длины твитов в символах. Какой метод определения размера ячейки использован на приведенном графике? [Sturgers 1926], [Scott 1979] или [Freedman, Diaconis 1981]? Постройте график рассеивания, который бы показывал связь с длиной твита во времени. Используя geom_hline(), наложите две линии: 140 символов и 280. Сделайте прозрачность 0.1. Постройте график рассеивания, который бы показывал связь с длиной твита во времени. Разбейте и раскрасьте твиты на основании наличия в них интернет ссылок. Можно ли утверждать, что твиты со ссылками длиннее? Постройте вайолинплот, которые показывает распределение значений длины твитов в зависимости от наличия в них интернет ссылок. Найдите твиты которые содержат корень america, которые встречаются больше одного раза, и фасетизируйте по таким словам. Lorem ipsum — классический текст-заполнитель на основе трактата Марка Туллия Цицерона “О пределах добра и зла.” Его используют, чтобы посмотреть, как страница смотриться, когда заполнена текстом↩︎ "],["ссылки-на-литературу.html", "Ссылки на литературу", " Ссылки на литературу "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
